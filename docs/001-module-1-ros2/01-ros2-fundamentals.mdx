---
title: "ROS2 Fundamentals: Nodes, Topics, Services"
sidebar_label: "ROS2 Fundamentals"
sidebar_position: 1
description: "Learn the fundamental concepts of ROS2: Nodes, Topics, and Services for humanoid control"
keywords: [ros2, nodes, topics, services, robotics]
---

# ROS2 Fundamentals: Nodes, Topics, Services

## Introduction

Welcome to the foundation of robotics communication! ROS2 (Robot Operating System 2) provides the communication backbone for all robotics applications. In this lesson, you'll learn the core concepts that enable humanoid robots to function as integrated systems.

## What is ROS2?

ROS2 is a flexible framework for writing robot software. It's not an operating system but rather a collection of tools, libraries, and conventions that aim to simplify the task of creating complex robotic behavior across a heterogeneous cluster of computers.

### Key Advantages:
- **Distributed**: Nodes can run on different machines
- **Real-time**: Optimized for time-critical robotic applications
- **Multi-language**: Support for C++, Python, and other languages
- **Middleware**: DDS (Data Distribution Service) for reliable communication

## Core Concepts

### Nodes
A node is a process that performs computation. Nodes are the fundamental building blocks of ROS2 applications. In a humanoid robot, you might have nodes for:
- Sensor processing
- Motor control
- Path planning
- Perception
- Decision making

### Topics
Topics enable one-way communication between nodes using a publisher-subscriber model. Data flows from publishers to subscribers. Common topics in humanoid robots:
- `/joint_states` - Current joint positions
- `/cmd_vel` - Velocity commands
- `/camera/image_raw` - Camera images
- `/imu/data` - Inertial measurement data

### Services
Services provide request-response communication between nodes. A client sends a request and receives a response. Examples:
- `/get_map` - Request the current map
- `/set_mode` - Change robot operating mode
- `/get_joint_state` - Request specific joint information

## Hands-On Lab: Basic ROS2 Communication

Let's create our first ROS2 nodes to understand the communication patterns.

### Publisher Node: Simple Message Publisher

```python title="code-examples/ros2-module/simple_publisher.py"
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class SimplePublisher(Node):
    def __init__(self):
        super().__init__('simple_publisher')
        self.publisher = self.create_publisher(String, 'chatter', 10)
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = String()
        msg.data = f'Hello World: {self.i}'
        self.publisher.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')
        self.i += 1

def main(args=None):
    rclpy.init(args=args)
    simple_publisher = SimplePublisher()
    rclpy.spin(simple_publisher)
    simple_publisher.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Subscriber Node: Simple Message Subscriber

```python title="code-examples/ros2-module/simple_subscriber.py"
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class SimpleSubscriber(Node):
    def __init__(self):
        super().__init__('simple_subscriber')
        self.subscription = self.create_subscription(
            String,
            'chatter',
            self.listener_callback,
            10)
        self.subscription  # prevent unused variable warning

    def listener_callback(self, msg):
        self.get_logger().info(f'I heard: "{msg.data}"')

def main(args=None):
    rclpy.init(args=args)
    simple_subscriber = SimpleSubscriber()
    rclpy.spin(simple_subscriber)
    simple_subscriber.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Service Server: Simple Service

```python title="code-examples/ros2-module/simple_service.py"
import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts

class SimpleService(Node):
    def __init__(self):
        super().__init__('simple_service')
        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)

    def add_two_ints_callback(self, request, response):
        response.sum = request.a + request.b
        self.get_logger().info(f'Incoming request\na: {request.a}, b: {request.b}')
        return response

def main(args=None):
    rclpy.init(args=args)
    simple_service = SimpleService()
    rclpy.spin(simple_service)
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Service Client: Simple Client

```python title="code-examples/ros2-module/simple_client.py"
import sys
import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts

class SimpleClient(Node):
    def __init__(self):
        super().__init__('simple_client')
        self.cli = self.create_client(AddTwoInts, 'add_two_ints')
        while not self.cli.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Service not available, waiting again...')
        self.req = AddTwoInts.Request()

    def send_request(self, a, b):
        self.req.a = a
        self.req.b = b
        future = self.cli.call_async(self.req)
        rclpy.spin_until_future_complete(self, future)
        return future.result()

def main(args=None):
    rclpy.init(args=args)
    simple_client = SimpleClient()
    response = simple_client.send_request(int(sys.argv[1]), int(sys.argv[2]))
    if response:
        simple_client.get_logger().info(f'Result of add_two_ints: {response.sum}')
    else:
        simple_client.get_logger().info('Service call failed')
    simple_client.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Running the Examples

1. **Source ROS2 environment**:
```bash
source /opt/ros/humble/setup.bash
```

2. **Run the publisher**:
```bash
python3 code-examples/ros2-module/simple_publisher.py
```

3. **In another terminal, run the subscriber**:
```bash
python3 code-examples/ros2-module/simple_subscriber.py
```

4. **Run the service server**:
```bash
python3 code-examples/ros2-module/simple_service.py
```

5. **In another terminal, run the client**:
```bash
python3 code-examples/ros2-module/simple_client.py 5 10
```

## ROS2 Launch Files

Launch files allow you to start multiple nodes at once with a single command:

```python title="code-examples/ros2-module/demo_launch.py"
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='demo_nodes_py',
            executable='talker',
            name='publisher_node'
        ),
        Node(
            package='demo_nodes_py',
            executable='listener',
            name='subscriber_node'
        )
    ])
```

## Key Takeaways

- **Nodes** are the basic computational units in ROS2
- **Topics** enable asynchronous data flow between nodes
- **Services** provide synchronous request-response communication
- **Launch files** help manage complex multi-node systems

## Next Steps

In the next lesson, we'll explore how to use Python agents to control humanoid robots through ROS2 interfaces.