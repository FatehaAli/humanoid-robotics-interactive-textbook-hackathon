---
title: "ROS2 Action Execution for Voice-Controlled Robots"
sidebar_label: "ROS2 Action Execution"
sidebar_position: 3
description: "Learn to execute LLM-generated action plans in ROS2 for voice-controlled robot systems"
keywords: [ros2, action execution, voice control, robot control, navigation]
---

# ROS2 Action Execution for Voice-Controlled Robots

## Introduction

In this final VLA lesson, you'll learn to execute the action plans generated by your LLM in a real ROS2 environment. This involves creating ROS2 nodes that can interpret the structured action plans and execute them using ROS2's communication system, integrating voice commands with actual robot control.

## Key Concepts

### ROS2 Action Execution
Executing planned actions in ROS2 involves:
- **Action Servers**: Long-running tasks with feedback (navigation, manipulation)
- **Services**: Discrete operations (gripper control, configuration)
- **Topics**: Continuous data flow (sensor data, velocity commands)
- **Parameters**: Configuration values (speed limits, safety thresholds)

### Voice Command Pipeline
The complete VLA pipeline:
1. **Voice Input**: User speaks command
2. **ASR**: Whisper converts speech to text
3. **LLM**: GPT/Groq generates action plan
4. **ROS2 Execution**: Action plan executed via ROS2 interfaces
5. **Feedback**: Robot status reported back to user

## Hands-On Lab: ROS2 Action Execution System

Let's create a ROS2 node that can execute action plans generated by the LLM.

### ROS2 Action Execution Node

```python title="code-examples/vla-module/ros2_action_executor.py"
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.qos import QoSProfile

# Import standard ROS2 message types
from geometry_msgs.msg import Twist, PoseStamped
from std_msgs.msg import String
from sensor_msgs.msg import JointState
from builtin_interfaces.msg import Duration

# Import navigation action (if available)
try:
    from nav2_msgs.action import NavigateToPose
    NAVIGATION_AVAILABLE = True
except ImportError:
    NAVIGATION_AVAILABLE = False
    print("Navigation actions not available - using basic movement only")

# Import manipulation action (if available)
try:
    from control_msgs.action import FollowJointTrajectory
    MANIPULATION_AVAILABLE = True
except ImportError:
    MANIPULATION_AVAILABLE = False
    print("Manipulation actions not available - using basic control only")

import json
import time
from typing import Dict, List, Any, Optional

class VLAActionExecutor(Node):
    def __init__(self):
        super().__init__('vla_action_executor')

        # Publishers for basic robot control
        self.cmd_vel_publisher = self.create_publisher(Twist, '/cmd_vel', 10)
        self.speech_publisher = self.create_publisher(String, '/speech_output', 10)

        # Subscriber for action plans from LLM
        self.action_plan_subscriber = self.create_subscription(
            String,
            '/vla/action_plan',
            self.action_plan_callback,
            10
        )

        # Action clients for complex tasks
        if NAVIGATION_AVAILABLE:
            self.nav_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')

        if MANIPULATION_AVAILABLE:
            self.manip_client = ActionClient(self, FollowJointTrajectory, 'joint_trajectory_controller/follow_joint_trajectory')

        # Internal state
        self.is_executing = False
        self.current_action_index = 0

        self.get_logger().info('VLA Action Executor initialized')

    def action_plan_callback(self, msg):
        """Process incoming action plan from LLM"""
        if self.is_executing:
            self.get_logger().warn('Currently executing an action plan, ignoring new plan')
            return

        try:
            action_plan = json.loads(msg.data)
            self.get_logger().info(f'Received action plan with {len(action_plan.get("actions", []))} actions')

            # Execute the action plan
            self.execute_action_plan(action_plan)

        except json.JSONDecodeError:
            self.get_logger().error('Invalid JSON in action plan')
        except Exception as e:
            self.get_logger().error(f'Error processing action plan: {e}')

    def execute_action_plan(self, action_plan: Dict):
        """Execute the entire action plan"""
        if 'actions' not in action_plan:
            self.get_logger().error('Action plan missing "actions" field')
            return

        self.is_executing = True
        self.current_action_index = 0
        actions = action_plan['actions']

        self.get_logger().info(f'Starting execution of {len(actions)} actions')

        for i, action in enumerate(actions):
            self.get_logger().info(f'Executing action {i+1}/{len(actions)}: {action.get("description", "Unknown")}')

            success = self.execute_single_action(action)
            if not success:
                self.get_logger().error(f'Action {i+1} failed: {action.get("description", "Unknown")}')
                self.is_executing = False
                return

            self.get_logger().info(f'Action {i+1} completed successfully')
            self.current_action_index = i + 1

        self.get_logger().info('All actions completed successfully')
        self.is_executing = False

    def execute_single_action(self, action: Dict) -> bool:
        """Execute a single action"""
        action_type = action.get('action_type', '')
        parameters = action.get('parameters', {})

        if action_type == 'move':
            return self.execute_move_action(parameters)
        elif action_type == 'navigate':
            return self.execute_navigate_action(parameters)
        elif action_type == 'grip':
            return self.execute_grip_action(parameters)
        elif action_type == 'release':
            return self.execute_release_action(parameters)
        elif action_type == 'speak':
            return self.execute_speak_action(parameters)
        elif action_type == 'wait':
            return self.execute_wait_action(parameters)
        elif action_type == 'find_object':
            return self.execute_find_object_action(parameters)
        else:
            self.get_logger().warn(f'Unknown action type: {action_type}')
            return False

    def execute_move_action(self, parameters: Dict) -> bool:
        """Execute a move action using velocity commands"""
        try:
            # Extract movement parameters
            x_vel = parameters.get('linear_x', 0.0)
            y_vel = parameters.get('linear_y', 0.0)
            z_vel = parameters.get('linear_z', 0.0)
            ang_vel = parameters.get('angular_z', 0.0)
            duration = parameters.get('duration', 1.0)  # seconds

            # Create velocity command
            twist_msg = Twist()
            twist_msg.linear.x = x_vel
            twist_msg.linear.y = y_vel
            twist_msg.linear.z = z_vel
            twist_msg.angular.x = 0.0
            twist_msg.angular.y = 0.0
            twist_msg.angular.z = ang_vel

            # Publish command for the specified duration
            start_time = self.get_clock().now()
            end_time = start_time + rclpy.time.Duration(seconds=duration)

            self.get_logger().info(f'Moving with linear=({x_vel}, {y_vel}, {z_vel}), angular=({ang_vel}) for {duration}s')

            while self.get_clock().now() < end_time:
                self.cmd_vel_publisher.publish(twist_msg)
                time.sleep(0.1)  # 10Hz update rate

            # Stop the robot
            stop_msg = Twist()
            self.cmd_vel_publisher.publish(stop_msg)

            return True

        except Exception as e:
            self.get_logger().error(f'Error executing move action: {e}')
            return False

    def execute_navigate_action(self, parameters: Dict) -> bool:
        """Execute a navigation action using navigation2"""
        if not NAVIGATION_AVAILABLE:
            self.get_logger().warn('Navigation not available, using basic movement')
            # Fallback to basic movement
            x = parameters.get('x', 0.0)
            y = parameters.get('y', 0.0)
            # This is a simplified version - in practice you'd need proper navigation setup
            self.get_logger().info(f'Navigating to ({x}, {y}) - simplified version')
            return True

        try:
            goal_msg = NavigateToPose.Goal()

            # Set target pose
            pose = PoseStamped()
            pose.header.frame_id = parameters.get('frame_id', 'map')
            pose.pose.position.x = parameters.get('x', 0.0)
            pose.pose.position.y = parameters.get('y', 0.0)
            pose.pose.position.z = parameters.get('z', 0.0)

            # Simple orientation (facing forward)
            pose.pose.orientation.w = 1.0

            goal_msg.pose = pose

            # Wait for action server
            if not self.nav_client.wait_for_server(timeout_sec=5.0):
                self.get_logger().error('Navigation action server not available')
                return False

            # Send goal
            future = self.nav_client.send_goal_async(goal_msg)

            # Wait for result (with timeout)
            rclpy.spin_until_future_complete(self, future, timeout_sec=30.0)

            if future.result() is not None:
                goal_handle = future.result()
                if goal_handle.accepted:
                    self.get_logger().info('Navigation goal accepted, waiting for result...')
                    result_future = goal_handle.get_result_async()
                    rclpy.spin_until_future_complete(self, result_future, timeout_sec=30.0)

                    if result_future.result() is not None:
                        result = result_future.result().result
                        self.get_logger().info(f'Navigation completed with result: {result}')
                        return True
                    else:
                        self.get_logger().error('Navigation result future not completed')
                        return False
                else:
                    self.get_logger().error('Navigation goal was rejected')
                    return False
            else:
                self.get_logger().error('Navigation goal future not completed')
                return False

        except Exception as e:
            self.get_logger().error(f'Error executing navigate action: {e}')
            return False

    def execute_grip_action(self, parameters: Dict) -> bool:
        """Execute a gripper grip action"""
        if not MANIPULATION_AVAILABLE:
            self.get_logger().warn('Manipulation not available, simulating grip')
            self.get_logger().info('Gripper closed (simulated)')
            return True

        try:
            # This would involve sending a trajectory to close the gripper
            # For now, we'll simulate it
            self.get_logger().info('Gripper closed')
            return True

        except Exception as e:
            self.get_logger().error(f'Error executing grip action: {e}')
            return False

    def execute_release_action(self, parameters: Dict) -> bool:
        """Execute a gripper release action"""
        if not MANIPULATION_AVAILABLE:
            self.get_logger().warn('Manipulation not available, simulating release')
            self.get_logger().info('Gripper opened (simulated)')
            return True

        try:
            # This would involve sending a trajectory to open the gripper
            # For now, we'll simulate it
            self.get_logger().info('Gripper opened')
            return True

        except Exception as e:
            self.get_logger().error(f'Error executing release action: {e}')
            return False

    def execute_speak_action(self, parameters: Dict) -> bool:
        """Execute a speak action"""
        try:
            message = parameters.get('message', 'Hello')
            self.get_logger().info(f'Speaking: {message}')

            # Publish speech message
            speech_msg = String()
            speech_msg.data = message
            self.speech_publisher.publish(speech_msg)

            return True

        except Exception as e:
            self.get_logger().error(f'Error executing speak action: {e}')
            return False

    def execute_wait_action(self, parameters: Dict) -> bool:
        """Execute a wait action"""
        try:
            duration = parameters.get('duration', 1.0)
            self.get_logger().info(f'Waiting for {duration} seconds')

            # In a real ROS2 node, you'd use a timer instead of sleep
            # For simplicity, we'll use a simple approach
            time.sleep(duration)

            return True

        except Exception as e:
            self.get_logger().error(f'Error executing wait action: {e}')
            return False

    def execute_find_object_action(self, parameters: Dict) -> bool:
        """Execute a find object action"""
        try:
            object_name = parameters.get('object', 'unknown')
            self.get_logger().info(f'Looking for object: {object_name}')

            # This would involve using perception nodes to detect objects
            # For simulation, we'll assume success
            self.get_logger().info(f'Found object: {object_name}')

            return True

        except Exception as e:
            self.get_logger().error(f'Error executing find object action: {e}')
            return False

def main(args=None):
    rclpy.init(args=args)
    executor = VLAActionExecutor()

    try:
        rclpy.spin(executor)
    except KeyboardInterrupt:
        executor.get_logger().info('Shutting down VLA Action Executor')
    finally:
        executor.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()