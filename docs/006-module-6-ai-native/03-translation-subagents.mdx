---
title: "Urdu Translation & Claude Code Sub-Agent Tools"
sidebar_label: "Urdu Translation & Code Sub-Agents"
sidebar_position: 3
description: "Implement Urdu translation service and Claude Code sub-agent tools for multilingual robotics education"
keywords: [urdu, translation, claude, code, sub-agents, ai, multilingual]
---

# Urdu Translation & Claude Code Sub-Agent Tools

## Introduction

In this final AI-Native lesson, you'll implement multilingual support with Urdu translation and Claude Code sub-agent tools. These features make robotics education accessible to Urdu speakers and provide AI-powered code assistance for learning robotics programming concepts.

## Key Concepts

### Urdu Translation System
The translation service includes:
- **Neural Machine Translation**: Use modern NMT models for quality
- **Technical Term Handling**: Preserve robotics and AI terminology
- **Cultural Adaptation**: Adapt examples and explanations culturally
- **Real-time Translation**: On-demand content translation

### Claude Code Sub-Agents
AI-powered code tools that:
- **Explain Code**: Provide detailed explanations of robotics code
- **Debug Code**: Identify and fix errors in robotics code
- **Generate Code**: Create robotics code examples based on requirements
- **Code Review**: Analyze code quality and best practices

## Hands-On Lab: Translation and Code Sub-Agent System

Let's create the complete system with Urdu translation and Claude Code tools.

### Translation and Code Sub-Agent Service

```python title="code-examples/ai-native-module/translation_service/translation_subagent_server.py"
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List, Dict, Optional
import openai
from openai import OpenAI
import os
import logging
from datetime import datetime
import asyncio
import json
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(title="Urdu Translation & Code Sub-Agents", version="1.0.0")

# Configuration
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
CLAUDE_API_KEY = os.getenv("CLAUDE_API_KEY", OPENAI_API_KEY)  # Using OpenAI compatible for Claude simulation

# Initialize clients
if OPENAI_API_KEY:
    client = OpenAI(api_key=OPENAI_API_KEY)
else:
    logger.warning("OPENAI_API_KEY not set, using mock responses")

# Define data models
class TranslationRequest(BaseModel):
    text: str
    source_lang: str = "en"
    target_lang: str = "ur"

class TranslationResponse(BaseModel):
    original_text: str
    translated_text: str
    source_lang: str
    target_lang: str
    confidence: float

class CodeRequest(BaseModel):
    code: str
    task: str  # "explain", "debug", "generate", "review"
    context: str = ""

class CodeResponse(BaseModel):
    original_code: str
    result_code: str
    explanation: str
    suggestions: List[str]
    task: str

class CodeSubAgentRequest(BaseModel):
    code: str
    task: str
    requirements: str = ""
    error_message: str = ""

class CodeSubAgentResponse(BaseModel):
    success: bool
    result: str
    explanation: str
    suggestions: List[str]

# Technical term glossary for robotics/AI terms
TECHNICAL_GLOSSARY = {
    # English to Urdu mappings for robotics terms
    "robot": "روبوٹ",
    "robotics": "روبوٹکس",
    "ROS": "ROS",
    "Gazebo": "گزیبو",
    "Isaac Sim": "آئزک سِم",
    "simulation": "سیمیولیشن",
    "sensor": "سینسر",
    "actuator": "ایکچوایٹر",
    "controller": "کنٹرولر",
    "navigation": "نیویگیشن",
    "perception": "ادراک",
    "control": "کنٹرول",
    "algorithm": "الگورتھم",
    "AI": "AI",
    "artificial intelligence": "مصنوعی ذہانت",
    "machine learning": "مشین لرننگ",
    "computer vision": "کمپیوٹر وژن",
    "natural language": "قدرتی زبان",
    "VLA": "VLA",
    "Vision-Language-Action": "وژن-لینگویج-ایکشن",
    "node": "نود",
    "topic": "ٹوپک",
    "service": "سروس",
    "message": "پیغام",
    "publisher": "پبلشر",
    "subscriber": "سبسکرائیبر",
    "URDF": "URDF",
    "joint": "جائنٹ",
    "link": "لنک",
    "transform": "ٹرانسفارم",
    "coordinate": "کوآرڈینیٹ",
    "frame": "فریم",
    "tf": "tf",
    "quaternion": "کوآٹرنین",
    "euler": "ایولر",
    "position": "پوزیشن",
    "orientation": "اورینٹیشن",
    "velocity": "ویلوسٹی",
    "acceleration": "ایکسیلریشن",
    "gripper": "گریپر",
    "manipulation": "مینوپولیشن",
    "grasp": "گریسپ",
    "trajectory": "ٹریجیکٹری",
    "motion": "موشن",
    "path": "پاتھ",
    "waypoint": "وی ویز",
    "obstacle": "رکاوٹ",
    "detection": "ڈیٹیکشن",
    "recognition": "رجوگنیشن",
    "segmentation": "سیگمینٹیشن",
    "classification": "کلاسیفکیشن",
    "detection": "ڈیٹیکشن",
    "tracking": "ٹریکنگ",
    "localization": "لوکلائزیشن",
    "mapping": "میپنگ",
    "SLAM": "SLAM",
    "localization": "لوکلائزیشن",
    "navigation": "نیویگیشن",
    "path planning": "پاتھ پلاننگ",
    "motion planning": "موشن پلاننگ",
    "kinematics": "کنیمیٹکس",
    "dynamics": "ڈائینمکس",
    "forward kinematics": "فرورڈ کنیمیٹکس",
    "inverse kinematics": "انورس کنیمیٹکس",
    "differential drive": "ڈفرینشل ڈرائیو",
    "omnidirectional": "اومنیڈائریکشنل",
    "holonomic": "ہولونومک",
    "non-holonomic": "نون-ہولونومک"
}

def translate_text(text: str, target_lang: str = "ur") -> str:
    """Translate text to target language with technical term preservation"""
    if target_lang.lower() != "ur":
        return text  # Only Urdu translation implemented

    # In a real implementation, you would use a proper translation API
    # For this demo, we'll use a combination of glossary and LLM
    if OPENAI_API_KEY:
        try:
            # Use GPT for translation with technical term preservation
            prompt = f"""
            Translate the following text to Urdu. Preserve technical terms like ROS, Gazebo, Isaac Sim, VLA, etc. in English.
            Use the following glossary for common robotics terms: {json.dumps(TECHNICAL_GLOSSARY, ensure_ascii=False)}

            Text to translate: {text}

            Provide only the translated text in response.
            """

            response = client.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "system", "content": "You are a professional translator specializing in technical content. Translate to Urdu while preserving English technical terms."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.3
            )
            return response.choices[0].message.content.strip()
        except Exception as e:
            logger.error(f"Error translating with OpenAI: {e}")
            # Fallback to simple glossary replacement
            return simple_urdu_translation(text)
    else:
        # Mock translation using glossary
        return simple_urdu_translation(text)

def simple_urdu_translation(text: str) -> str:
    """Simple glossary-based translation for demo purposes"""
    result = text
    for eng, urdu in TECHNICAL_GLOSSARY.items():
        result = result.replace(eng, urdu)
    return result

def explain_code(code: str, context: str = "") -> CodeSubAgentResponse:
    """Explain the given robotics code"""
    if OPENAI_API_KEY:
        try:
            prompt = f"""
            Explain the following robotics code in detail. Focus on ROS2 concepts, robot control, or simulation aspects if applicable.

            Code:
            {code}

            Context: {context}

            Provide:
            1. Line-by-line explanation
            2. Purpose of the code
            3. Key concepts used
            4. Potential improvements
            """

            response = client.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "system", "content": "You are an expert in robotics programming, particularly ROS2 and Python. Explain code clearly with focus on robotics applications."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.5
            )

            explanation = response.choices[0].message.content
            return CodeSubAgentResponse(
                success=True,
                result=explanation,
                explanation=explanation,
                suggestions=[]
            )
        except Exception as e:
            logger.error(f"Error explaining code: {e}")
            return CodeSubAgentResponse(
                success=False,
                result="Error explaining code",
                explanation="An error occurred while explaining the code",
                suggestions=[]
            )
    else:
        # Mock response
        return CodeSubAgentResponse(
            success=True,
            result=f"Explanation for code: {code[:50]}...",
            explanation=f"This code appears to implement robotics functionality. [MOCK RESPONSE - API key not configured]",
            suggestions=["Add comments", "Follow ROS2 conventions"]
        )

def debug_code(code: str, error_message: str = "") -> CodeSubAgentResponse:
    """Debug the given robotics code"""
    if OPENAI_API_KEY:
        try:
            prompt = f"""
            Debug the following robotics code and identify issues. If an error message is provided, focus on fixing that specific error.

            Code:
            {code}

            Error message: {error_message}

            Provide:
            1. Issues found in the code
            2. Corrected code
            3. Explanation of fixes
            4. Prevention tips
            """

            response = client.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "system", "content": "You are an expert debugger for robotics code, particularly ROS2 Python. Identify and fix issues."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.3
            )

            result = response.choices[0].message.content
            return CodeSubAgentResponse(
                success=True,
                result=result,
                explanation="Debugging completed",
                suggestions=[]
            )
        except Exception as e:
            logger.error(f"Error debugging code: {e}")
            return CodeSubAgentResponse(
                success=False,
                result="Error debugging code",
                explanation="An error occurred while debugging the code",
                suggestions=[]
            )
    else:
        # Mock response
        return CodeSubAgentResponse(
            success=True,
            result=f"Debug analysis for code: {code[:50]}...",
            explanation="No issues found or mock debugging performed [API key not configured]",
            suggestions=["Check imports", "Verify ROS2 node initialization"]
        )

def generate_code(requirements: str) -> CodeSubAgentResponse:
    """Generate robotics code based on requirements"""
    if OPENAI_API_KEY:
        try:
            prompt = f"""
            Generate Python code for ROS2 that satisfies the following requirements:

            Requirements:
            {requirements}

            The code should follow ROS2 best practices and be suitable for robotics applications.
            Include proper imports, node structure, and comments.
            """

            response = client.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "system", "content": "You are an expert in ROS2 Python programming. Generate clean, well-commented code that follows ROS2 best practices."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.7
            )

            generated_code = response.choices[0].message.content
            return CodeSubAgentResponse(
                success=True,
                result=generated_code,
                explanation="Code generated successfully",
                suggestions=[]
            )
        except Exception as e:
            logger.error(f"Error generating code: {e}")
            return CodeSubAgentResponse(
                success=False,
                result="Error generating code",
                explanation="An error occurred while generating the code",
                suggestions=[]
            )
    else:
        # Mock response
        return CodeSubAgentResponse(
            success=True,
            result=f"# Generated code for: {requirements[:30]}...\n# [MOCK RESPONSE - API key not configured]\nprint('Hello Robotics!')",
            explanation="Mock code generated [API key not configured]",
            suggestions=["Implement proper ROS2 node structure", "Add error handling"]
        )

@app.post("/api/translate", response_model=TranslationResponse)
async def translate(request: TranslationRequest):
    """Translate text between languages"""
    try:
        translated_text = translate_text(request.text, request.target_lang)

        # Calculate confidence based on translation method
        confidence = 0.8 if OPENAI_API_KEY else 0.5

        return TranslationResponse(
            original_text=request.text,
            translated_text=translated_text,
            source_lang=request.source_lang,
            target_lang=request.target_lang,
            confidence=confidence
        )
    except Exception as e:
        logger.error(f"Error in translation: {e}")
        raise HTTPException(status_code=500, detail=f"Translation error: {str(e)}")

@app.post("/api/code/assist", response_model=CodeSubAgentResponse)
async def code_assistance(request: CodeSubAgentRequest):
    """Provide code assistance using sub-agents"""
    try:
        if request.task == "explain":
            return explain_code(request.code, request.requirements)
        elif request.task == "debug":
            return debug_code(request.code, request.error_message)
        elif request.task == "generate":
            return generate_code(request.requirements)
        elif request.task == "review":
            # For review, we'll combine explanation and suggestions
            explanation_result = explain_code(request.code)
            if explanation_result.success:
                # Add review-specific suggestions
                suggestions = [
                    "Follow ROS2 naming conventions",
                    "Add proper error handling",
                    "Include documentation strings",
                    "Use appropriate logging"
                ]
                return CodeSubAgentResponse(
                    success=True,
                    result=explanation_result.result,
                    explanation=explanation_result.explanation,
                    suggestions=suggestions
                )
            else:
                return explanation_result
        else:
            raise HTTPException(status_code=400, detail=f"Unknown task: {request.task}")
    except Exception as e:
        logger.error(f"Error in code assistance: {e}")
        raise HTTPException(status_code=500, detail=f"Code assistance error: {str(e)}")

@app.post("/api/code/explain", response_model=CodeResponse)
async def explain_code_endpoint(request: CodeRequest):
    """Explain the given code"""
    try:
        result = explain_code(request.code, request.context)
        return CodeResponse(
            original_code=request.code,
            result_code=request.code,  # For explanation, original is returned
            explanation=result.explanation,
            suggestions=result.suggestions,
            task=request.task
        )
    except Exception as e:
        logger.error(f"Error explaining code: {e}")
        raise HTTPException(status_code=500, detail=f"Code explanation error: {str(e)}")

@app.post("/api/code/debug", response_model=CodeResponse)
async def debug_code_endpoint(request: CodeRequest):
    """Debug the given code"""
    try:
        result = debug_code(request.code, request.context)
        return CodeResponse(
            original_code=request.code,
            result_code=result.result if result.success else request.code,
            explanation=result.explanation,
            suggestions=result.suggestions,
            task=request.task
        )
    except Exception as e:
        logger.error(f"Error debugging code: {e}")
        raise HTTPException(status_code=500, detail=f"Code debugging error: {str(e)}")

@app.get("/api/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "service": "Translation & Code Sub-Agents"}

@app.get("/api/glossary")
async def get_technical_glossary():
    """Get the technical term glossary"""
    return {"glossary": TECHNICAL_GLOSSARY, "language": "en-ur", "count": len(TECHNICAL_GLOSSARY)}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8002)