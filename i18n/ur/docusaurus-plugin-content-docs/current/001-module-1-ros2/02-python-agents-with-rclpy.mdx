---
title: "Python Agents with rclpy for Humanoid Control"
sidebar_label: "Python Agents with rclpy"
sidebar_position: 2
description: "Learn to integrate Python agents with ROS2 using rclpy for humanoid robot control"
keywords: [python, rclpy, agents, control, robotics]
---

# Python Agents with rclpy for Humanoid Control

## Introduction

In this lesson, we'll explore how to use Python agents to control humanoid robots through ROS2. The `rclpy` library provides Python bindings for ROS2, allowing you to create nodes, publish/subscribe to topics, and use services directly from Python scripts.

## Why Python Agents?

Python agents bridge the gap between high-level decision making and low-level robot control. They can:
- Process sensor data and make decisions
- Send commands to robot actuators
- Interface with external systems and APIs
- Implement complex control algorithms

## Understanding rclpy

The `rclpy` library is the Python client library for ROS2. It provides:

- **Node Creation**: Create ROS2 nodes from Python scripts
- **Topic Communication**: Publish and subscribe to topics
- **Service Calls**: Make service requests and provide services
- **Parameter Management**: Access and modify node parameters
- **Action Handling**: Work with long-running tasks

## Hands-On Lab: Python Agent for Robot Control

Let's create a Python agent that can control a humanoid robot by publishing commands to ROS2 topics.

### Basic Robot Controller Agent

```python title="code-examples/ros2-module/python_robot_controller.py"
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from sensor_msgs.msg import JointState
import time

class RobotControllerAgent(Node):
    def __init__(self):
        super().__init__('robot_controller_agent')

        # Publisher for velocity commands
        self.cmd_vel_publisher = self.create_publisher(Twist, '/cmd_vel', 10)

        # Subscriber for joint states
        self.joint_state_subscriber = self.create_subscription(
            JointState,
            '/joint_states',
            self.joint_state_callback,
            10
        )

        # Timer for control loop
        self.control_timer = self.create_timer(0.1, self.control_loop)  # 10Hz

        # Internal state
        self.current_joint_positions = {}
        self.command_sequence = [
            {'linear_x': 1.0, 'angular_z': 0.0, 'duration': 2.0},  # Move forward
            {'linear_x': 0.0, 'angular_z': 0.5, 'duration': 2.0},  # Turn right
            {'linear_x': 0.5, 'angular_z': 0.0, 'duration': 1.0},  # Move forward
        ]
        self.command_index = 0
        self.command_start_time = self.get_clock().now()

        self.get_logger().info('Robot Controller Agent initialized')

    def joint_state_callback(self, msg):
        """Process joint state messages"""
        for i, name in enumerate(msg.name):
            if i < len(msg.position):
                self.current_joint_positions[name] = msg.position[i]

        # Log some joint positions
        if 'left_leg_joint' in self.current_joint_positions:
            self.get_logger().info(
                f'Left leg position: {self.current_joint_positions["left_leg_joint"]:.3f}'
            )

    def control_loop(self):
        """Main control loop"""
        if self.command_index >= len(self.command_sequence):
            # Stop if all commands completed
            self.stop_robot()
            return

        command = self.command_sequence[self.command_index]
        current_time = self.get_clock().now()
        elapsed = (current_time - self.command_start_time).nanoseconds / 1e9

        if elapsed < command['duration']:
            # Execute current command
            self.execute_command(command)
        else:
            # Move to next command
            self.command_index += 1
            if self.command_index < len(self.command_sequence):
                self.command_start_time = self.get_clock().now()
                self.get_logger().info(f'Starting command {self.command_index + 1}')

    def execute_command(self, command):
        """Execute a single movement command"""
        twist_msg = Twist()
        twist_msg.linear.x = command['linear_x']
        twist_msg.angular.z = command['angular_z']

        self.cmd_vel_publisher.publish(twist_msg)

        self.get_logger().info(
            f'Sending command: linear_x={command["linear_x"]}, '
            f'angular_z={command["angular_z"]}'
        )

    def stop_robot(self):
        """Stop the robot"""
        stop_msg = Twist()
        self.cmd_vel_publisher.publish(stop_msg)
        self.get_logger().info('Robot stopped - all commands completed')

def main(args=None):
    rclpy.init(args=args)
    controller_agent = RobotControllerAgent()

    try:
        rclpy.spin(controller_agent)
    except KeyboardInterrupt:
        controller_agent.get_logger().info('Interrupted by user')
    finally:
        controller_agent.stop_robot()
        controller_agent.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Advanced Agent: Perception-Based Controller

```python title="code-examples/ros2-module/perception_controller_agent.py"
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import LaserScan, Image
from geometry_msgs.msg import Twist
from cv_bridge import CvBridge
import cv2
import numpy as np

class PerceptionControllerAgent(Node):
    def __init__(self):
        super().__init__('perception_controller_agent')

        # Publishers and subscribers
        self.cmd_vel_publisher = self.create_publisher(Twist, '/cmd_vel', 10)
        self.laser_subscriber = self.create_subscription(
            LaserScan, '/scan', self.laser_callback, 10
        )
        self.camera_subscriber = self.create_subscription(
            Image, '/camera/image_raw', self.camera_callback, 10
        )

        # Internal state
        self.bridge = CvBridge()
        self.obstacle_distance = float('inf')
        self.camera_image = None
        self.avoiding_obstacle = False

        # Control parameters
        self.safe_distance = 1.0  # meters
        self.linear_speed = 0.5
        self.angular_speed = 0.8

        # Control timer
        self.control_timer = self.create_timer(0.05, self.control_loop)  # 20Hz

        self.get_logger().info('Perception Controller Agent initialized')

    def laser_callback(self, msg):
        """Process laser scan data"""
        # Get distance to nearest obstacle in front (Â±30 degrees)
        front_ranges = msg.ranges[330:390]  # Assuming 720-point scan
        front_ranges = [r for r in front_ranges if not np.isnan(r) and r > 0]

        if front_ranges:
            self.obstacle_distance = min(front_ranges)
        else:
            self.obstacle_distance = float('inf')

    def camera_callback(self, msg):
        """Process camera image"""
        try:
            self.camera_image = self.bridge.imgmsg_to_cv2(msg, "bgr8")
        except Exception as e:
            self.get_logger().error(f'Error converting image: {e}')

    def control_loop(self):
        """Main control loop with obstacle avoidance"""
        cmd_vel = Twist()

        if self.obstacle_distance < self.safe_distance:
            # Obstacle detected - avoid
            self.avoiding_obstacle = True
            cmd_vel.linear.x = 0.0
            cmd_vel.angular.z = self.angular_speed  # Turn left
            self.get_logger().info(f'Obstacle detected! Distance: {self.obstacle_distance:.2f}m - Turning')
        else:
            # Clear path - move forward
            self.avoiding_obstacle = False
            cmd_vel.linear.x = self.linear_speed
            cmd_vel.angular.z = 0.0
            self.get_logger().info(f'Path clear. Distance: {self.obstacle_distance:.2f}m - Moving forward')

        # Publish command
        self.cmd_vel_publisher.publish(cmd_vel)

def main(args=None):
    rclpy.init(args=args)
    agent = PerceptionControllerAgent()

    try:
        rclpy.spin(agent)
    except KeyboardInterrupt:
        agent.get_logger().info('Interrupted by user')
    finally:
        # Stop robot on exit
        stop_msg = Twist()
        agent.cmd_vel_publisher.publish(stop_msg)
        agent.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Agent Configuration and Parameters

```python title="code-examples/ros2-module/configurable_agent.py"
import rclpy
from rclpy.node import Node
from rclpy.parameter import Parameter
from geometry_msgs.msg import Twist
import json

class ConfigurableAgent(Node):
    def __init__(self):
        super().__init__('configurable_agent')

        # Declare parameters with defaults
        self.declare_parameter('linear_speed', 0.5)
        self.declare_parameter('angular_speed', 0.8)
        self.declare_parameter('safe_distance', 1.0)
        self.declare_parameter('behavior_mode', 'explore')

        # Publishers
        self.cmd_vel_publisher = self.create_publisher(Twist, '/cmd_vel', 10)

        # Control timer
        self.control_timer = self.create_timer(0.1, self.control_loop)

        self.get_logger().info('Configurable Agent initialized')

    def control_loop(self):
        """Control loop using parameters"""
        linear_speed = self.get_parameter('linear_speed').value
        angular_speed = self.get_parameter('angular_speed').value
        behavior_mode = self.get_parameter('behavior_mode').value

        cmd_vel = Twist()

        if behavior_mode == 'explore':
            cmd_vel.linear.x = linear_speed
            cmd_vel.angular.z = 0.1  # Gentle turn for exploration
        elif behavior_mode == 'patrol':
            cmd_vel.linear.x = linear_speed
            cmd_vel.angular.z = 0.0
        elif behavior_mode == 'stop':
            cmd_vel.linear.x = 0.0
            cmd_vel.angular.z = 0.0

        self.cmd_vel_publisher.publish(cmd_vel)

        self.get_logger().info(
            f'Behavior: {behavior_mode}, '
            f'Linear: {cmd_vel.linear.x}, '
            f'Angular: {cmd_vel.angular.z}'
        )

def main(args=None):
    rclpy.init(args=args)
    agent = ConfigurableAgent()

    try:
        rclpy.spin(agent)
    except KeyboardInterrupt:
        agent.get_logger().info('Interrupted by user')
    finally:
        # Stop robot
        stop_msg = Twist()
        agent.cmd_vel_publisher.publish(stop_msg)
        agent.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Running the Python Agents

1. **Basic Robot Controller**:
```bash
python3 code-examples/ros2-module/python_robot_controller.py
```

2. **Perception Controller** (requires camera and laser scan):
```bash
python3 code-examples/ros2-module/perception_controller_agent.py
```

3. **Configurable Agent** with parameters:
```bash
python3 code-examples/ros2-module/configurable_agent.py
```

You can also set parameters at runtime:
```bash
ros2 run demo_nodes_py listener __params:=path/to/params.yaml
```

## Best Practices for Python Agents

### 1. Error Handling
Always include proper error handling in your agents:

```python
def safe_publish(self, msg):
    try:
        self.publisher.publish(msg)
    except Exception as e:
        self.get_logger().error(f'Failed to publish message: {e}')
```

### 2. Resource Management
Properly clean up resources when the node shuts down:

```python
def destroy_node(self):
    # Stop robot before shutting down
    stop_msg = Twist()
    self.cmd_vel_publisher.publish(stop_msg)
    super().destroy_node()
```

### 3. Logging
Use appropriate log levels for different types of information:

```python
self.get_logger().info('Normal operation info')
self.get_logger().warn('Warning about potential issues')
self.get_logger().error('Error occurred')
```

## Key Takeaways

- Python agents use `rclpy` to interface with ROS2
- Agents can publish commands and subscribe to sensor data
- Parameter servers allow runtime configuration
- Proper error handling and resource management are essential
- Agents enable complex decision-making and control logic

## Next Steps

In the next lesson, we'll learn about URDF (Unified Robot Description Format) for defining humanoid robot models in ROS2.