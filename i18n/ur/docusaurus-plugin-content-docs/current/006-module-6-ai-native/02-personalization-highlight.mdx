---
title: "Personalization & Highlight-to-Ask Features"
sidebar_label: "Personalization & Highlight-to-Ask"
sidebar_position: 2
description: "Implement personalization engine and highlight-to-ask functionality for interactive learning"
keywords: [personalization, highlight-to-ask, ai, interactive, learning]
---

# Personalization & Highlight-to-Ask Features

## Introduction

Personalization enhances the learning experience by adapting content to individual users' needs, preferences, and learning progress. Highlight-to-ask allows users to select text and ask questions about it, creating an interactive learning environment. In this lesson, you'll implement both features to create a more engaging educational experience.

## Key Concepts

### Personalization Engine
The personalization system includes:
- **User Profiling**: Track user interactions, preferences, and progress
- **Adaptive Content**: Adjust content difficulty and presentation
- **Learning Analytics**: Analyze user behavior to improve recommendations
- **Progress Tracking**: Monitor learning milestones and achievements

### Highlight-to-Ask
This feature enables:
- **Text Selection**: Users can select any text in the content
- **Contextual Questions**: Ask questions about the selected text
- **AI Integration**: Use LLMs to provide relevant answers
- **Learning Enhancement**: Deepen understanding through interactive Q&A

## Hands-On Lab: Personalization and Highlight System

Let's create a personalization engine with highlight-to-ask functionality.

### Personalization and Highlight Service

```python title="code-examples/ai-native-module/personalization_engine/personalization_service.py"
from fastapi import FastAPI, HTTPException, Depends
from pydantic import BaseModel
from typing import Dict, List, Optional, Any
import psycopg2
from psycopg2.extras import RealDictCursor
import os
import logging
from datetime import datetime, timedelta
from enum import Enum
import hashlib
from sentence_transformers import SentenceTransformer
import openai
from openai import OpenAI

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(title="Personalization Engine", version="1.0.0")

# Configuration
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
NEON_DATABASE_URL = os.getenv("NEON_DATABASE_URL")

# Initialize clients
if OPENAI_API_KEY:
    client = OpenAI(api_key=OPENAI_API_KEY)
else:
    logger.warning("OPENAI_API_KEY not set, using mock responses")

# Sentence transformer for content analysis
embedder = SentenceTransformer('all-MiniLM-L6-v2')

# Database connection
def get_db_connection():
    if not NEON_DATABASE_URL:
        logger.warning("NEON_DATABASE_URL not set, using mock database")
        return None
    return psycopg2.connect(NEON_DATABASE_URL, cursor_factory=RealDictCursor)

# Define data models
class UserLevel(str, Enum):
    BEGINNER = "beginner"
    INTERMEDIATE = "intermediate"
    ADVANCED = "advanced"

class UserPreferences(BaseModel):
    preferred_topics: List[str] = []
    learning_style: str = "visual"  # visual, auditory, reading, kinesthetic
    difficulty_level: UserLevel = UserLevel.INTERMEDIATE
    preferred_language: str = "en"

class UserProfile(BaseModel):
    user_id: str
    preferences: UserPreferences
    learning_history: List[Dict] = []
    current_module: str = ""
    progress: Dict[str, float] = {}  # module -> completion percentage
    last_access: datetime = None

class HighlightRequest(BaseModel):
    user_id: str
    text: str
    context: str = ""
    content_id: str = ""

class QuestionResponse(BaseModel):
    question: str
    answer: str
    confidence: float
    sources: List[str] = []

class ContentAdaptation(BaseModel):
    content_id: str
    user_id: str
    adapted_content: str
    difficulty_level: UserLevel
    explanation_style: str

# Initialize database tables
def init_database():
    conn = get_db_connection()
    if not conn:
        logger.warning("No database connection, skipping initialization")
        return

    try:
        with conn.cursor() as cur:
            # Create users table
            cur.execute("""
                CREATE TABLE IF NOT EXISTS users (
                    id TEXT PRIMARY KEY,
                    preferences JSONB,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)

            # Create user_interactions table
            cur.execute("""
                CREATE TABLE IF NOT EXISTS user_interactions (
                    id SERIAL PRIMARY KEY,
                    user_id TEXT REFERENCES users(id),
                    interaction_type TEXT,
                    content_id TEXT,
                    text TEXT,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    metadata JSONB
                )
            """)

            # Create content_adaptations table
            cur.execute("""
                CREATE TABLE IF NOT EXISTS content_adaptations (
                    id SERIAL PRIMARY KEY,
                    content_id TEXT,
                    user_id TEXT REFERENCES users(id),
                    adapted_content TEXT,
                    difficulty_level TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)

            conn.commit()
            logger.info("Database tables initialized")
    except Exception as e:
        logger.error(f"Error initializing database: {e}")
        conn.rollback()
    finally:
        conn.close()

# Initialize on startup
@app.on_event("startup")
def startup_event():
    init_database()

def get_user_profile(user_id: str) -> UserProfile:
    """Get user profile from database or create default"""
    conn = get_db_connection()
    if not conn:
        # Return default profile if no database
        return UserProfile(
            user_id=user_id,
            preferences=UserPreferences(),
            learning_history=[],
            progress={}
        )

    try:
        with conn.cursor() as cur:
            cur.execute("SELECT * FROM users WHERE id = %s", (user_id,))
            user_row = cur.fetchone()

            if user_row:
                return UserProfile(
                    user_id=user_id,
                    preferences=UserPreferences(**user_row['preferences']),
                    learning_history=[],  # Would load from separate table in real implementation
                    progress={}  # Would load from separate table
                )
            else:
                # Create default user
                default_prefs = UserPreferences()
                cur.execute(
                    "INSERT INTO users (id, preferences) VALUES (%s, %s)",
                    (user_id, default_prefs.dict())
                )
                conn.commit()

                return UserProfile(
                    user_id=user_id,
                    preferences=default_prefs,
                    learning_history=[],
                    progress={}
                )
    except Exception as e:
        logger.error(f"Error getting user profile: {e}")
        # Return default profile
        return UserProfile(
            user_id=user_id,
            preferences=UserPreferences(),
            learning_history=[],
            progress={}
        )
    finally:
        conn.close()

def update_user_interaction(user_id: str, interaction_type: str, content_id: str, text: str, metadata: Dict = None):
    """Record user interaction in database"""
    if not NEON_DATABASE_URL:
        return  # Skip if no database

    conn = get_db_connection()
    if not conn:
        return

    try:
        with conn.cursor() as cur:
            cur.execute(
                "INSERT INTO user_interactions (user_id, interaction_type, content_id, text, metadata) VALUES (%s, %s, %s, %s, %s)",
                (user_id, interaction_type, content_id, text, metadata or {})
            )
            conn.commit()
    except Exception as e:
        logger.error(f"Error recording user interaction: {e}")
    finally:
        conn.close()

@app.get("/api/user/{user_id}/profile", response_model=UserProfile)
async def get_user_profile_endpoint(user_id: str):
    """Get user profile"""
    profile = get_user_profile(user_id)
    return profile

@app.put("/api/user/{user_id}/preferences")
async def update_user_preferences(user_id: str, preferences: UserPreferences):
    """Update user preferences"""
    conn = get_db_connection()
    if not conn:
        raise HTTPException(status_code=500, detail="Database not available")

    try:
        with conn.cursor() as cur:
            cur.execute(
                "UPDATE users SET preferences = %s, updated_at = CURRENT_TIMESTAMP WHERE id = %s",
                (preferences.dict(), user_id)
            )
            conn.commit()

            # Record the preference update
            update_user_interaction(user_id, "preferences_update", "", "", preferences.dict())

            return {"status": "success", "user_id": user_id}
    except Exception as e:
        logger.error(f"Error updating user preferences: {e}")
        raise HTTPException(status_code=500, detail=f"Error updating preferences: {str(e)}")
    finally:
        conn.close()

@app.post("/api/highlight/ask", response_model=QuestionResponse)
async def highlight_ask(request: HighlightRequest):
    """Process a highlight-to-ask request"""
    try:
        # Record the interaction
        update_user_interaction(
            request.user_id,
            "highlight_ask",
            request.content_id,
            request.text,
            {"context": request.context}
        )

        # Get user profile to customize response
        user_profile = get_user_profile(request.user_id)

        # Prepare context for LLM based on user's level
        difficulty_context = ""
        if user_profile.preferences.difficulty_level == UserLevel.BEGINNER:
            difficulty_context = "Explain this concept in simple terms for a beginner."
        elif user_profile.preferences.difficulty_level == UserLevel.ADVANCED:
            difficulty_context = "Provide a detailed, technical explanation."

        # Generate response using OpenAI (or mock if no API key)
        if OPENAI_API_KEY:
            prompt = f"""
            Context: {request.context}
            Highlighted text: {request.text}
            {difficulty_context}

            Please explain the highlighted text in a way that's appropriate for the user's level and provide helpful examples if relevant.
            """

            response = client.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "system", "content": "You are a helpful educational assistant. Explain concepts clearly and provide examples when helpful."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.7
            )
            answer = response.choices[0].message.content
            confidence = 0.9  # Assume high confidence for LLM responses
        else:
            # Mock response
            answer = f"I can explain '{request.text}' for you. [MOCK RESPONSE - API key not configured]"
            confidence = 0.7

        return QuestionResponse(
            question=f"Explain: {request.text}",
            answer=answer,
            confidence=confidence,
            sources=[request.content_id] if request.content_id else []
        )

    except Exception as e:
        logger.error(f"Error processing highlight ask: {e}")
        raise HTTPException(status_code=500, detail=f"Error processing request: {str(e)}")

@app.post("/api/content/adaptive", response_model=ContentAdaptation)
async def adapt_content(adaptation: ContentAdaptation):
    """Adapt content based on user profile"""
    try:
        user_profile = get_user_profile(adaptation.user_id)

        # Record the adaptation request
        update_user_interaction(
            adaptation.user_id,
            "content_adaptation",
            adaptation.content_id,
            "",
            {"original_content": adaptation.adapted_content}
        )

        # In a real implementation, this would use more sophisticated adaptation
        # For now, we'll just adjust based on difficulty level
        content = adaptation.adapted_content

        if user_profile.preferences.difficulty_level == UserLevel.BEGINNER:
            # Add more explanations and simpler language
            content += "\n\n*Note: This concept is explained at a beginner level with additional context.*"
        elif user_profile.preferences.difficulty_level == UserLevel.ADVANCED:
            # Add more technical details
            content += "\n\n*For advanced users: This concept can be extended with additional technical considerations.*"

        # Save adaptation to database
        if NEON_DATABASE_URL:
            conn = get_db_connection()
            if conn:
                try:
                    with conn.cursor() as cur:
                        cur.execute("""
                            INSERT INTO content_adaptations
                            (content_id, user_id, adapted_content, difficulty_level)
                            VALUES (%s, %s, %s, %s)
                        """, (
                            adaptation.content_id,
                            adaptation.user_id,
                            content,
                            adaptation.difficulty_level.value
                        ))
                        conn.commit()
                except Exception as e:
                    logger.error(f"Error saving content adaptation: {e}")
                finally:
                    conn.close()

        return ContentAdaptation(
            content_id=adaptation.content_id,
            user_id=adaptation.user_id,
            adapted_content=content,
            difficulty_level=adaptation.difficulty_level,
            explanation_style=user_profile.preferences.learning_style
        )

    except Exception as e:
        logger.error(f"Error adapting content: {e}")
        raise HTTPException(status_code=500, detail=f"Error adapting content: {str(e)}")

@app.get("/api/user/{user_id}/recommendations")
async def get_recommendations(user_id: str):
    """Get personalized content recommendations"""
    try:
        profile = get_user_profile(user_id)

        # Simple recommendation logic based on user preferences and progress
        recommendations = []

        # If user prefers certain topics, recommend content from those areas
        if profile.preferences.preferred_topics:
            for topic in profile.preferences.preferred_topics[:3]:  # Top 3 topics
                recommendations.append({
                    "topic": topic,
                    "content_id": f"content_{topic}",
                    "title": f"Recommended: {topic.title()} Content",
                    "difficulty": profile.preferences.difficulty_level.value,
                    "relevance_score": 0.9
                })

        # If user is at beginner level, recommend more foundational content
        if profile.preferences.difficulty_level == UserLevel.BEGINNER:
            recommendations.append({
                "topic": "fundamentals",
                "content_id": "fundamentals_101",
                "title": "Robotics Fundamentals",
                "difficulty": "beginner",
                "relevance_score": 0.8
            })

        return {"recommendations": recommendations, "user_level": profile.preferences.difficulty_level.value}

    except Exception as e:
        logger.error(f"Error getting recommendations: {e}")
        raise HTTPException(status_code=500, detail=f"Error getting recommendations: {str(e)}")

@app.get("/api/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "service": "Personalization Engine"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8001)